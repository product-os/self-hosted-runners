#!/usr/bin/env bash

set -ae

[[ $VERBOSE =~ true|True|yes|Yes|on|On|1 ]] && set -x

# these tmpfs mounts need the executable bit set
mount -o remount,rw,exec tmpfs /tmp
mount -o remount,rw,exec tmpfs /run

function mount_as_tmpfs() {
    # unmount any existing binds
    umount "${1}" || true
    # create mountpoint for a new tmpfs
    mkdir -p "${1}.tmpfs"
    # create the tmpfs with execute permissions
    mount -t tmpfs -o rw,exec tmpfs "${1}.tmpfs"
    # copy the contents of the original directory to the tmpfs
    cp -a "${1}"/* "${1}.tmpfs"
    # bind mount the tmpfs over the original
    mount --bind "${1}.tmpfs" "${1}"
}

# create tmpfs overlays for some directories that need to be writable
# but should not persist container restarts
for dir in /home/runner /opt; do
    mount_as_tmpfs "${dir}" || true
done

# override /proc/cpuinfo for ARM variants
# see: https://github.com/containerd/containerd/pull/7636
function override_cpuinfo() {
    # nothing to do if the cpuinfo is already correct
    if grep -q "CPU architecture: ${1}" /proc/cpuinfo; then
        return 0
    fi

    echo "CPU architecture: ${1}" >/tmp/cpuinfo
    mount --bind /tmp/cpuinfo /proc/cpuinfo
}

case "$(uname -m)" in
aarch64)
    override_cpuinfo 8
    ;;
armv7l)
    override_cpuinfo 7
    ;;
esac
