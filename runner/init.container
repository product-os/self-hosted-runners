#!/usr/bin/env bash

# The main goal of this init script is to set up the filesystem
# in a way that changes are not persisted across container restarts.

# This is done by creating an overlayfs mount with the current root
# as the lower layer, and a temporary directory as the upper layer.
# Then, the chroot environment is executed with the overlayfs mount
# as the root directory.

set -e

# shellcheck disable=SC1091
. /etc/s6-overlay/scripts/functions

truthy "${DISABLE:-}" && exit 0

truthy "${VERBOSE:-}" && set -x

# When provided with a docker host socket, this container should relaunch
# copy of itself with the --rm flag to guarantee ephemeral storage.
if docker info >/dev/null 2>&1 && [[ -n "${DOCKER_HOST:-}" ]]; then
    # For now assume the hostname is the short container ID.
    container_id="$(docker inspect -f '{{.Id}}' "$(hostname)")"

    # Docker inspect template to generate a run command with the same properties as the current container.
    # https://gist.github.com/efrecon/8ce9c75d518b6eb863f667442d7bc679
    run_command=$(docker inspect --format "$(</run.tpl)" "${container_id}")

    # Remove the DOCKER_HOST variable from the run command to prevent recursion!
    run_command=$(echo "${run_command}" | sed '/DOCKER_HOST/d')
    run_command=$(echo "${run_command}" | sed '/docker.sock/d')
    run_command=$(echo "${run_command}" | sed '/balena.sock/d')

    echo "RUN COMMAND: ${run_command}"
    eval "exec ${run_command}" >/dev/null 2>&1
    exit 0
fi

ACTIONS_RUNNER_RUNTIME_LABELS="$(get_runtime_labels)"
export ACTIONS_RUNNER_RUNTIME_LABELS

if truthy "${DRY_RUN:-}"; then
    echo "PERFORMING DRY RUN"
    rm /etc/s6-overlay/s6-rc.d/user/contents.d/runner
    # Execute the s6-overlay entrypoint
    exec /init /etc/s6-overlay/scripts/healthcheck
else
    # Execute the s6-overlay entrypoint
    exec /init
fi
